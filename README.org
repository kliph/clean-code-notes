* Notes on Clean Code
By Robert C. Martin
* Foreword
By James O. Coplien

Sensible, but offers 0 evidence.  Retreads the tired ground of appealing to Eastern mysticism to back up the sensible advice.
* Introduction

Ah yes, anecdotal evidence.  You'll have to work "/hard/"to learn this stuff.  Hopefully there will be some evidence to back these heuristics up.  Maybe?

But really though, case studies and these sorts of heuristics seem great.  Sensible approaches to writing software are great.  Surely if these sensible approaches are so profoundly useful there should be a way to measure their usefulness.

I feel a real appeal to machismo and toxic masculinity in this book, when it tells me this is "/hard work/" in contrast to a "feel good" book you can read on a plane.  I feel the appeal to machismo and toxic masculinity when it mentions that you'll gain a rich understanding of "principles, patterns, practices, and heuristics ... in your gut, fingers, and heart."  I could do without it.

I don't need a condescending tone to guilt-trip me into accepting what you say.  If it's sensible, show me how to do it and I will.  If it's measurable, demonstrate its effectiveness.

Finally, the WTFs per minute cartoon is great :D.
* Chapter 1: Clean Code
#+caption: There Will Be +Code+ Blood
[[https://media.giphy.com/media/tt3eTxBT0cgtW/giphy.gif]]

The doctors hand-washing anecdote argues in favor of strong validation via evidence.  It does not suggest that doctors have the prestige and privilege to buck the system, going against what their managers say in order to do what's best for their bosses (patients).

Grady Booch mentions that code should be readable.  I'm interested in that concept, specifically because I reckon that two programmers could have wildly different subjective definitions for what makes a certain bit of code readable.  I wonder whether there is any research determining the parameters that feed into this concept of readability.  This [[https://faculty.washington.edu/ajko/books/cooperative-software-development/comprehension.html][chapter from Andrew J. Ko]]
 seems like a good resource.

For what it's worth, I agree with Booch that clean code should read like prose.

In the next section (covering "Big" Dave Thomas), Martin asserts that "[t]here is, after all, a difference between code that is easy to read and code that is easy to change."  I see no evidence to support this dichotomy.  It certainly seems possible that readability and changeability are polar opposites, but it also seems possible that many overlapping factors contribute to what we (assuming we both hold similar referents) term readability and changeability.  We can't just take these assumptions for granted /a priori/.  We must investigate and interrogate these assumptions to learn whether they can tell us any meaningful information about the world.

Martin also points out that Thomas mentions twice that smaller code is better.  This brings to mind the some of the work in Adam Tornhill's /[[https://pragprog.com/book/atcrime/your-code-as-a-crime-scene][Your Code as a Crime Scene]]/.  I should revisit that when I can find the time.  It would seem that there is an argument to be made in favor of smaller code bases given constant rates of errors (bugs).

Ron Jeffries makes an interesting point on refactoring to extract methods: "If it's a method, [refactor it], resulting in one method that says more clearly *what* it does, and some submethods saying *how* it is done." Bold indicates my emphasis.

Interesting that Martin's well-known programmers are all white men.  Might be interesting to ask a more diverse sample to share their opinions on what makes code "clean".  I don't presume that the findings would be too different, but one can't know without conducting the research.

Okay, so, comparing Martin's "School of Thought" to a martial arts tradition is a total cop out.  It's not as if martial arts traditions [[https://www.ncbi.nlm.nih.gov/pubmed/31191109][haven't]] [[https://www.ncbi.nlm.nih.gov/pubmed/31240587][been]] [[https://www.ncbi.nlm.nih.gov/pubmed/31373295][rigorously]] [[https://www.ncbi.nlm.nih.gov/pubmed/31343555][studied]] [[https://www.ncbi.nlm.nih.gov/pubmed/31336837][and]] [[https://www.ncbi.nlm.nih.gov/pubmed/31282402][tested]] [[https://www.ncbi.nlm.nih.gov/pubmed/31261524][for]] [[https://www.ncbi.nlm.nih.gov/pubmed/30846917][effectiveness]] (and I couldn't resist a [[https://www.ncbi.nlm.nih.gov/pubmed/30832454][couple]] [[https://www.ncbi.nlm.nih.gov/pubmed/30694967][more]]).  Why not do the same for these ideas that, at this point, "/are/ absolutes"?

[[https://media.giphy.com/media/sJiAhV5VPheTK/giphy.gif]]

#+BEGIN_QUOTE
In the 80s and 90s we had editors like Emacs that kept track of every keystroke.
#+END_QUOTE

LOL that's *rich*!  See [[https://en.wikipedia.org/wiki/Emacs#cite_note-1][these]] [[https://en.wikipedia.org/wiki/Emacs#cite_note-jwz_timeline-2][citations]] for more information.
* Chapter 2: Meaningful Names
by Tim Ottinger

Nice, choose names that communicate intent.  Seems reminiscent of Zach Tellman's /[[https://leanpub.com/elementsofclojure][Elements of Clojure]]/ and Bozhidar Batsov's [[https://guide.clojure.style/][Clojure Style Guide]] (not to mention, although pausing specifically to mention, Batsov's work on the [[https://rubystyle.guide/][Ruby Style Guide]]).

In the Make Meaningful Distinctions section, Ottinger mentions something I found very puzzling initially:

#+BEGIN_QUOTE
For example, because you can't use the same name to refer to two different things in the same scope, you might be tempted to change one name in an arbitrary way.  Sometimes this is done by misspelling one, leading to the surprising situation where correcting spelling errors leads to an inability to compile.
#+END_QUOTE

I've definitely encountered this!

In a footnote, Ottinger mentions using =klass= because =class= was used elsewhere.  See also:

#+BEGIN_SRC js
  var that = this;
#+END_SRC

I can certainly see why it would be necessary.  But still.  Yuck.

[[https://media.giphy.com/media/ZF32u4EqI0AHqUQucs/giphy.gif]]

"/The length of a name should correspond to the size of its scope./"  This is a nice heuristic and one I use myself.  Here's a hypothesis.  Seems like testing comprehension by varying name length by objective scope would be a relatively straightforward experiment.  Conditions could be "long names" for large scope / "short names" for small scope, "short names" for large scope / "long names" for small scope, random length names for all scopes, etc.

Not sure I buy the argument regarding Interfaces and Implementations.  Those seem to be cases where you have a meaningful distinction between multiple bits of code dealing with the same referent.  Ottinger seems to think it is necessary to use encodings for these cases, but using =I= as a prefix is "a distraction at best and too much information at worst."  =AbstractFoo=, =IFoo=, and =FooImpl= all make sense to me.

I'm totally here for picking one word per concept.  That's a practice I use all the time.

[[https://media.giphy.com/media/NEvPzZ8bd1V4Y/giphy.gif]]

Regarding the assumption that everyone who reads your code will be programmers, I say, "Uhhhh, not so sure that's always the case, but granted."  When Ottinger recommends using "computer science ... terms, algorithm names, pattern names, path terms and so forth."  I [[https://twitter.com/elementsofclj/status/1074710832938971136][disagree]].

It's incumbent on the author to define the terms for the reader.  I have often accomplished this by including a Glossary defining terms of art in a project.  This goes for domain-specific terms as well as general purpose terms which may or may not be used in novel ways to solve the problem at hand.

[[https://media.giphy.com/media/P5wPrhzZDdeJW/giphy.gif]]
* Chapter 3: Functions
